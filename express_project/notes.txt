Express used for:
-easy API setup
-less overhead, fewer props to setup - instatiate express app and listen for req on port
-Express is a framework for Node.js
-Server-sided app

client needs to send HTTP req to server.
code on client side makes req to express server side application.
server side application runs logic and will send back a response to client side application.

In package.json - changing type to "modules" - remember to add .mjs to files so you can use ES6 modules and syntax for import/export

query params:
1. can be used on client side to send data across different pages (eg. passing state)
2. send from client side to server side to add additional data to req that usually isn't added to HTTP req body (eg. when using GET request you could filter or sort server response) 
* should not be used to send sensitive data (eg. passwords) - use req body instead

POST req:
data sent from client to server is sent as req.body/payload
server then does things like validation and parsing before applying logic/sending to db/file storage etc.
returns 201 status if req successful and new resource was created.
*need to use middleware to parse JSON data from req.body so express can use data - middleware function should be called/invoked before the req is made


PUT, PATCH req:
used to update existing resources
-PATCH - partial update
-PUT - replace entire resource --> so you need to include all fields in req.body, even parts that aren't being updated since the PUT request is overwriting the resource (or they will be null)

DELETE req:
used to delete resources
-------------------------
MIDDLEWARE - 
const <middleware> = (req, res, next) => {
	HANDLE req, res? logic,
	next() 
	//pass control to next middleware function in req,res cycle
	//next() is optional - if you don't call it, the req,res cycle will end and the client will never get a response
	-you can have as many middleware called in sequential order using next()
}
app.use(<middleware>, <middleware-2>, etc) ---> global
----
add to route for specific routes:

app.get('/users', <middleware-1>,<middleware-2>, etc, (req,res)=> {route logic})
----
middleware is a function that runs between req and res cycle. It MUST be defined and app.use() it before the route handler (or inside the route handler before the route logic/req,res handler logic)
<handling req & res> middleware functions have access to req + res objects and (if) there is the next middleware function in the apps req,res cycle
Middleware functions can be enabled globally (all routes) or used for specific routes/endpoints (pass as argument in that specific route/reused on multiple routes)

*optionally pass an error to next. If you pass anything to the next function, Express will interpret this as an error and will skip all remaining middleware in the stack (except for error-handling middleware).

app.use((req, res, next) => {
  if (someCondition) {
    next(new Error('Something went wrong'));
  } else {
    next();
  }
});
---------------------------
Express Validator middleware: 
https://express-validator.github.io/docs/
*-->This is server-side validation which is MUCH MORE IMP and necessary - compared to client-side validation (which can be bypassed)
--> so always implement server-side validation
use them like middleware in routes before the req,res handler logic
-->functions you can import (destructured) from express-validator = body, header, param, query, cookie,
-->*check (check is the mainAPI used for validating and sanitizing HTTP req and gives you access to all build in validators and sanitizers and utility functions/methods)
*for body() validator if the arg is passed as an array it will check all fields in the body of the req [body('key1').methods, body('key2').methods]
You would then be able to create validation chains by chaining methods to these functions
eg. The query function validator specifically is used to create a validation chain for query parameters, you chain on validation methods depending on how you want to validate the query parameter
app.get('/users', <validator middleware>, (req,res)=> {route logic})

*note: validators do not report/throw validation errors to users/client automatically (it will validate but will not throw an error) - you need to handle the error 

you can create 'unlimited' validation chain to keep calling more methods of validation on the same (eg. query('queryparam'))

you can use if (result.isEmpty()){} to check if there were any validation errors (returns bool)
you can use matchedData(req) to get the data that was validated when passing it to res logic

**Scehma validation:
-obj that has all validators defined so you reduce DRY code in routes
-use checkSchema(schemaObj) inside route




